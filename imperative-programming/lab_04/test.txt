ids0.txt

int main() { // comment
    printf ("Hello\n"); /* and another */
    printf ("Greetings\n");
return 0;
}

ids1.txt

int main() {
    int c;
//    int line_comment_counter = 0;
    int block_comment_counter = 0;
//    int state = 0;

    while ((c = getchar()) != EOF) {

        if (state & IN_LINE_COMMENT) {
            if (c == '\n') {
                state &= ~IN_LINE_COMMENT; // end of line comment
            }
            continue;
        }

        if (state & IN_BLOCK_COMMENT) {
            if (c != '*') continue;
            int c_next = getchar();
            if (c_next == '/') {
                state &= ~IN_BLOCK_COMMENT; // end of block comment
            } else {
                ungetc(c_next, stdin);
            }
            /* continue; */
        }

        if (c == '/') {
            int c_next = getchar();
            if (c_next == '/') {
                state |= IN_LINE_COMMENT; // line comment begins
//                ++line_comment_counter;
            } else if (c_next == '*') {
                state |= IN_BLOCK_COMMENT; // block comment begins
                ++block_comment_counter;
            } else {
                ungetc(c_next, stdin);
            }
            continue;
        }
    }
/*
    printf("%d %d\n", block_comment_counter, line_comment_counter);
    return 0;
*/
}

ids2.txt

int count[MAX_CHARS] = { 0 };

int cmp (const void *a, const void *b) {
    return count[*(int*)a] - count[*(int*)b];
}

int main() {
    int indices[MAX_CHARS];
    for (int _i = 0; _i < MAX_CHARS; ++_i) {
        indices[_i] = _i;
    }
/*
    int c;
    while ((c = getchar()) != EOF) {
        ++count[c];
    }
*/
    qsort(indices, MAX_CHARS, sizeof(int), cmp);

    for (int i = 0; i < MAX_CHARS; ++i) {
        printf("index aaa bbb %4d \" %4d\n", indices[i], count[indices[i]]);
    }

    return 0;
}

#include <stdio.h>
#include <math.h>
#define N 100
/*
// Generates the sequence of n samples by incrementing the start value
// using the step size (|step| > 1.e-5).
// 0 <= n <= N
// for n = 0 return empty array
// for n = 1 return one-element array, with array[0] = start
void range(double array[], double start, double step, int n) {
    for(int i=0; i<n; start+=step) {
        array[i++] = start;
    }
    return;
}
*/

// Returns n evenly spaced samples, calculated over the interval [start, stop].
// 0 <= n <= N
// for n = 0 return empty array
// for n = 1 return one-element array, with array[0] = start
void linspace(double array[], double start, double stop, int n) {
    if (n == 0) return;
    if (n == 1) {
        array[0] = start;
        return;
    }
    double step = (stop - start) / (n - 1);
    double x = start;
    for (int i = 0; i < n; ++i) {
        array[i] = x;
        x += step;
    }
}

// Multiply each element of v by the value of scalar
void multiply_by_scalar(double v[], int n, double scalar) {
    for (int i = 0; i < n; ++i) {
        v[i] *= scalar;
    }
}

// Add to each element v1[i] value of v2[i]
void add(double v1[], const double v2[], int n) {
    for (int i = 0; i < n; ++i) {
        v1[i] += v2[i];
    }
}

// calculate and return the dot product of v1 and v2
double dot_product(const double v1[], const double v2[], int n) {
    double sum = 0.;
    for (int i = 0; i < n; ++i) {
        sum += v1[i] * v2[i];
    }
    return sum;
}

// read double vector of size n
void read_vector(double v[], int n) {
    for (int i = 0; i < n; ++i) {
        scanf("%lf", v + i);
    }
}

// print double vector of size n (with 2 figures after the decimal point)
void print_vector(const double v[], int n) {
    for (int i = 0; i < n; ++i) {
        printf("%.2f ", v[i]);
    }
    printf("\n");
}



----------RESULTS----------
ids0.txt: 2
ids1.txt: 11
ids2.txt: 11
ids3.txt: 26